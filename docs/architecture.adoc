= SPEC-1: MonStim Analyzer GUI Architecture
:sectnums:
:toc:

== Background

MonStim Analyzer is a graphical application developed for managing and analyzing EMG signals across multiple experiments, datasets, and recording sessions. Originally created to support the author's own electrophysiological experiments, the tool evolved into a more general-purpose GUI designed to be extensible and usable by other researchers or lab personnel.

The application addresses a common need in experimental neuroscience and physiology: managing large volumes of structured session data, inspecting and modifying signal metadata (e.g., channel names, latency windows), and visualizing EMG-derived features such as reflex curves, M-max, or H-reflex peaks.

Early versions lacked a formal design, leading to tight coupling and difficult scalability. As requirements grew (e.g., undo/redo support, dataset exclusion/restoration, command-based extensibility), architectural improvements were made to decouple UI, domain logic, and data persistence.

This document defines a baseline architecture to guide future growth and reduce refactor effort as new features are added.

== Requirements

System requirements are categorized below using the MoSCoW prioritization model.

=== Must Have

* Support post-hoc analysis of EMG data recorded via an external LabView tool.
* Parse structured CSV files and convert them into a compressed binary format with accompanying JSON metadata.
* Organize EMG recordings hierarchically into experiments â†’ datasets â†’ sessions â†’ recordings.
* Allow annotations and non-destructive user edits via structured JSON overlays.
* Enable users to exclude or restore datasets, sessions, and recordings.
* Display EMG data using domain-specific plots: EMG traces, reflex curves, M-max, H-reflex.
* Provide GUI-based tools to:

  * Rename channel labels at various hierarchy levels.
  * Invert polarity for selected channels.
  * Define latency windows for reflex analysis.
* Support undo/redo via a command pattern.
* Persist unsaved changes warning on close.
* Use PyQt6 for GUI implementation.

=== Should Have

* Allow export of reports or figures from the GUI.
* Include user-friendly splash, help, and about dialogs.
* Maintain separation between data logic and GUI logic.
* Cache previously loaded experiments and restore them quickly.
* Provide modular managers (data, report, plot) to keep code maintainable.

=== Could Have

* Plugin system to support user-defined plots, data transforms, or analysis dialogs.
* Support future formats (e.g., EDF, HDF5) with adapter pattern.
* Theming or dark mode support.

=== Won't Have (for now)

* Real-time or live signal acquisition.
* Direct integration with LabView or other acquisition software.

== Method

The MonStim Analyzer is structured around a clean separation of concerns across two Python packages: `monstim_signals` (data and domain logic) and `monstim_gui` (GUI and interaction logic). This structure allows for scalability, non-destructive editing, and domain-driven development.

=== Component Architecture

[plantuml, target=architecture]
----
@startuml
' =========================
' monstim_gui package
' =========================

package "monstim_gui" {
    class EMGAnalysisGUI {
        - expts_dict
        - current_experiment
        - current_dataset
        - current_session
        - plot_widget
        - data_selection_widget
        - reports_widget
        - menu_bar
        - plot_pane
        - command_invoker
        + undo()
        + redo()
        + exclude_recording()
        + restore_recording()
        + remove_session()
        + remove_dataset()
        + select_channels()
        + change_channel_names()
        + update_reflex_time_windows()
        + invert_channel_polarity()
        + import_expt_data()
        + show_preferences_window()
        + refresh_existing_experiments()
        + unpack_existing_experiments()
    }

    class CommandInvoker {
        - parent: EMGAnalysisGUI
        - history: deque
        - redo_stack: deque
        + execute(cmd)
        + undo()
        + redo()
        + get_undo_command_name()
        + get_redo_command_name()
        + remove_command_by_name()
    }

    abstract class Command {
        + execute()
        + undo()
    }

    class ExcludeRecordingCommand
    class RestoreRecordingCommand
    class ExcludeSessionCommand
    class RestoreSessionCommand
    class ExcludeDatasetCommand
    class RestoreDatasetCommand
    class InvertChannelPolarityCommand
    class SetLatencyWindowsCommand

    Command <|-- ExcludeRecordingCommand
    Command <|-- RestoreRecordingCommand
    Command <|-- ExcludeSessionCommand
    Command <|-- RestoreSessionCommand
    Command <|-- ExcludeDatasetCommand
    Command <|-- RestoreDatasetCommand
    Command <|-- InvertChannelPolarityCommand
    Command <|-- SetLatencyWindowsCommand

    EMGAnalysisGUI --> CommandInvoker
    EMGAnalysisGUI --> PlotWidget
    EMGAnalysisGUI --> DataSelectionWidget
    EMGAnalysisGUI --> ReportsWidget
    EMGAnalysisGUI --> MenuBar
    EMGAnalysisGUI --> PlotPane

    CommandInvoker --> Command
    CommandInvoker ..> MenuBar : updates undo/redo labels

    PlotWidget --> PlotPane
    PlotWidget --> DataSelectionWidget
}

' =========================
' monstim_signals package
' =========================

package "monstim_signals.domain" {
    class Experiment
    class Dataset
    class Session
    class Recording

    Experiment "1" o-- "*" Dataset
    Dataset "1" o-- "*" Session
    Session "1" o-- "*" Recording
}

package "monstim_signals.io" {
    class ExperimentRepository
    class DatasetRepository
    class SessionRepository
    class RecordingRepository

    ExperimentRepository --> Experiment
    DatasetRepository --> Dataset
    SessionRepository --> Session
    RecordingRepository --> Recording

    ExperimentRepository "1" o-- "*" DatasetRepository
    DatasetRepository "1" o-- "*" SessionRepository
    SessionRepository "1" o-- "*" RecordingRepository
}

' =========================
' Integration
' =========================

EMGAnalysisGUI --> ExperimentRepository : loads/saves experiments
EMGAnalysisGUI --> Experiment
EMGAnalysisGUI --> Dataset
EMGAnalysisGUI --> Session
EMGAnalysisGUI --> Recording

PlotWidget --> Session : for plotting data

' Command pattern integration
CommandInvoker --> EMGAnalysisGUI
ExcludeRecordingCommand --> EMGAnalysisGUI
RestoreRecordingCommand --> EMGAnalysisGUI
ExcludeSessionCommand --> EMGAnalysisGUI
RestoreSessionCommand --> EMGAnalysisGUI
ExcludeDatasetCommand --> EMGAnalysisGUI
RestoreDatasetCommand --> EMGAnalysisGUI
InvertChannelPolarityCommand --> EMGAnalysisGUI
SetLatencyWindowsCommand --> EMGAnalysisGUI
@enduml
----


=== Data Flow and Persistence

* Raw recordings are exported from LabView as CSV.
* On import, repositories parse and convert them to compressed binary format and structured JSON metadata.
* Each recording is stored in a session folder containing all session recordings, with their corresponding binary, metadata, and annotation files.
* Session folders aggregate recordings and contain their own annotation overlays.
* Dataset and experiment folders follow the same pattern, allowing annotation logic to scale and remain hierarchical.
* User actions (e.g., exclude session, rename channel) are tracked as Command objects and applied to domain models in-memory.
* Annotations are stored separately as overlay JSON files, preserving the original data for reproducibility.

=== Command Pattern

Each user-editable action is encapsulated in a `Command` subclass. These are:

* Executed by `CommandInvoker`
* Recorded in history for undo/redo
* Operate directly on domain models (`Experiment`, `Dataset`, etc.)
* Trigger GUI updates through `EMGAnalysisGUI`

This pattern ensures loose coupling and future extensibility, and supports future features like macro replay or batch annotations.

=== Modularity

* `monstim_gui` has no direct file I/O logic: all data is accessed through repositories.
* `monstim_signals` has no PyQt6 dependencies.
* Plotting is handled by `PlotWidget`, which works through `SessionPlotters` in `Session` domain objects (Same goes for Dataset/Experiment levels of plotting and analysis).

This design enables testing of data logic independently of the GUI, supports potential CLI modes, and ensures clean layering.

== Implementation

Implementation can be structured in stages:

1. **Bootstrapping Core Architecture**

   * Define base domain classes (`Experiment`, `Dataset`, `Session`, `Recording`).
   * Implement corresponding repositories for load/save with folder-based hierarchy.
   * Design command base class and integrate undo/redo stack.

2. **GUI Setup (PyQt6)**

   * Implement `EMGAnalysisGUI` and primary widgets (`PlotPane`, `MenuBar`, `DataSelectionWidget`).
   * Wire command execution buttons and status bar updates.

3. **Data Conversion and Import**

   * Write CSV importers to convert to binary + metadata.
   * Add JSON overlay support for annotations.

4. **Plotting Integration**

   * Develop `PlotWidget` with session-driven plotting logic.
   * Connect selection changes to redraw plots.

5. **Annotation Commands**

   * Add user-driven actions: exclude, restore, invert polarity, rename channels, set latency windows.

6. **Persistence and Save Prompts**

   * Implement save-on-close warning with `has_unsaved_changes`.
   * Add support for refresh and reloading.

== Milestones

1. âœ… MVP version supporting H-reflex EMG experiments with full UI and undo/redo.
2. ðŸ”œ Support for multi-modal signals (e.g., force, stimulus traces).
3. ðŸ”œ Add protocol layer abstraction for long-form experiments with changing stimulus types.
4. ðŸ”œ Optional plugin mechanism for analysis routines or UI extensions.
5. ðŸ”œ Exporting annotated recordings or figures to standardized formats.

== Gathering Results

Evaluation criteria:

* **Load performance**: Time to load an experiment with >100 sessions.
* **Extensibility**: Time/effort to add new domain object (e.g., ForceTrace).
* **Reliability**: Stability of undo/redo stack across mixed operations.
* **User utility**: Can a lab user annotate and inspect data without needing to look at raw files?

Performance benchmarks and user feedback can guide further modularization or refactor priorities.
